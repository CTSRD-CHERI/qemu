
syntax = "proto3";

// package qemu.protos;

enum QEMULogInstrExcType {
  TRAP = 0;
  INTR = 1;
}

/* Values must be kept in sync with log_event_trace_state_t */
enum LogEventTraceState {
  START = 0;
  STOP = 1;
  FLUSH = 2;
}

/* Values must be kept in sync with log_event_ctx_update_op_t */
enum LogEventCtxUpdateOp {
  LOG_EVENT_CTX_OP_SWITCH = 0;
  LOG_EVENT_CTX_OP_SETUP = 1;
}

message QEMULogInstrCapability {
  bool valid = 1;
  bool sealed = 2;
  uint32 perms = 3;
  uint32 otype = 4;
  uint64 cap_base = 5;
  uint64 cap_cursor = 6;
  uint64 cap_length = 7;
}

message QEMULogInstrMem {
  bool is_load = 1;
  int32 size = 2;
  fixed64 addr = 3;
  oneof value {
    QEMULogInstrCapability cap_value = 4;
    double fp_value = 5;
    fixed64 int_value = 6;
  }
}

message QEMULogInstrReg {
  string name = 1;
  oneof value {
    fixed64 int_value = 2;
    double fp_value = 3;
    QEMULogInstrCapability cap_value = 4;
  }
}

message QEMULogInstrEvtTraceState {
  LogEventTraceState next_state = 1;
  fixed64 pc = 2;
}

message QEMULogInstrEvtCtxUpdate {
  LogEventCtxUpdateOp op = 1;
  uint64 pid = 2;
  uint64 tid = 3;
  uint64 cid = 4;
  string mode = 5;
}

message QEMULogInstrEvt {
  oneof event {
    QEMULogInstrEvtTraceState state = 1;
    QEMULogInstrEvtCtxUpdate ctx_update = 2;
    uint64 marker = 3;
  }
}

message QEMULogInstrExc {
  QEMULogInstrExcType type = 1;
  fixed64 vector = 2;
  int32 code = 3;
  fixed64 faultaddr = 4;
}

message QEMULogInstrEntry {
  fixed64 pc = 1;
  oneof insn {
    string disas = 2;
    bytes opcode = 3;
  }
  int32 cpu = 4;
  int32 asid = 5;
  string mode = 6;
  QEMULogInstrExc exception = 7;
  repeated QEMULogInstrMem mem = 8;
  repeated QEMULogInstrReg reg = 9;
  repeated QEMULogInstrEvt evt = 10;
}
